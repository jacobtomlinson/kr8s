"""Objects to represent Kubernetes resources.

This module provides classes that represent Kubernetes resources.
These classes are used to interact with resources in the Kubernetes API server.

WARNING: This typing stub file was generated by ci/gen_stubs.py
DO NOT MODIFY DIRECTLY
"""

from __future__ import annotations

import contextlib
import json
import pathlib
import re
import time
from functools import partial
from typing import Any, AsyncGenerator, BinaryIO, List, Literal, cast

import anyio
import httpx
import jsonpath
import yaml
from box import Box

import kr8s
import kr8s.asyncio
from kr8s._api import Api
from kr8s._async_utils import sync
from kr8s._data_utils import (
    dict_to_selector,
    dot_to_nested_dict,
    list_dict_unpack,
    xdict,
)
from kr8s._exceptions import NotFoundError, ServerError
from kr8s._exec import Exec
from kr8s._types import SpecType, SupportsKeysAndGetItem
from kr8s.asyncio.portforward import PortForward as AsyncPortForward
from kr8s.portforward import PortForward as SyncPortForward

from ._async_utils import run_sync, sync
from ._objects import APIObject as _APIObject
from ._objects import Binding as _Binding
from ._objects import ClusterRole as _ClusterRole
from ._objects import ClusterRoleBinding as _ClusterRoleBinding
from ._objects import ComponentStatus as _ComponentStatus
from ._objects import ConfigMap as _ConfigMap
from ._objects import ControllerRevision as _ControllerRevision
from ._objects import CronJob as _CronJob
from ._objects import CustomResourceDefinition as _CustomResourceDefinition
from ._objects import DaemonSet as _DaemonSet
from ._objects import Deployment as _Deployment
from ._objects import Endpoints as _Endpoints
from ._objects import Event as _Event
from ._objects import HorizontalPodAutoscaler as _HorizontalPodAutoscaler
from ._objects import Ingress as _Ingress
from ._objects import IngressClass as _IngressClass
from ._objects import Job as _Job
from ._objects import LimitRange as _LimitRange
from ._objects import Namespace as _Namespace
from ._objects import NetworkPolicy as _NetworkPolicy
from ._objects import Node as _Node
from ._objects import PersistentVolume as _PersistentVolume
from ._objects import PersistentVolumeClaim as _PersistentVolumeClaim
from ._objects import Pod as _Pod
from ._objects import PodDisruptionBudget as _PodDisruptionBudget
from ._objects import PodTemplate as _PodTemplate
from ._objects import ReplicaSet as _ReplicaSet
from ._objects import ReplicationController as _ReplicationController
from ._objects import ResourceQuota as _ResourceQuota
from ._objects import Role as _Role
from ._objects import RoleBinding as _RoleBinding
from ._objects import Secret as _Secret
from ._objects import Service as _Service
from ._objects import ServiceAccount as _ServiceAccount
from ._objects import StatefulSet as _StatefulSet
from ._objects import Table as _Table
from ._objects import get_class as _get_class
from ._objects import new_class as _new_class
from ._objects import object_from_name_type as _object_from_name_type
from ._objects import object_from_spec as _object_from_spec
from ._objects import objects_from_files as _objects_from_files

class APIObject(_APIObject):
    """Base class for Kubernetes objects."""

    version: str
    endpoint: str
    kind: str
    plural: str
    singular: str
    namespaced: bool
    scalable: bool
    scalable_spec: str
    _asyncio: bool

    def __init__(
        self, resource: SpecType, namespace: str | None = None, api: Api | None = None
    ) -> None:
        """Initialize an APIObject."""
        ...

    def __await__(self): ...
    def __repr__(self):
        """Return a string representation of the Kubernetes resource."""
        ...

    def __str__(self):
        """Return a string representation of the Kubernetes resource."""
        ...

    def __eq__(self, other): ...
    @property
    def api(self): ...
    @api.setter
    def api(self, value): ...
    @property
    def raw(self) -> Any:
        """Raw object returned from the Kubernetes API."""
        ...

    @raw.setter
    def raw(self, value: Any) -> None: ...
    @property
    def name(self) -> str:
        """Name of the Kubernetes resource."""
        ...

    @name.setter
    def name(self, value: str) -> None: ...
    @property
    def namespace(self) -> str | None:
        """Namespace of the Kubernetes resource."""
        ...

    @namespace.setter
    def namespace(self, value: str) -> None: ...
    @property
    def metadata(self) -> Box:
        """Metadata of the Kubernetes resource."""
        ...

    @metadata.setter
    def metadata(self, value: dict) -> None: ...
    @property
    def spec(self) -> Box:
        """Spec of the Kubernetes resource."""
        ...

    @spec.setter
    def spec(self, value: dict) -> None: ...
    @property
    def status(self) -> Box:
        """Status of the Kubernetes resource."""
        ...

    @status.setter
    def status(self, value: dict) -> None: ...
    @property
    def labels(self) -> Box:
        """Labels of the Kubernetes resource."""
        ...

    @labels.setter
    def labels(self, value: dict) -> None: ...
    @property
    def annotations(self) -> Box:
        """Annotations of the Kubernetes resource."""
        ...

    @annotations.setter
    def annotations(self, value: dict) -> None: ...
    @property
    def replicas(self) -> int:
        """Replicas of the Kubernetes resource."""
        ...

    @replicas.setter
    def replicas(self, value: int) -> None: ...
    @classmethod
    def get(
        cls,
        name: str | None = None,
        namespace: str | None = None,
        api: Api | None = None,
        label_selector: str | dict[str, str] | None = None,
        field_selector: str | dict[str, str] | None = None,
        timeout: int = 2,
        **kwargs,
    ) -> APIObject:
        """Get a Kubernetes resource by name or via selectors."""
        ...

    def exists(self, ensure=False) -> bool:
        """Check if this object exists in Kubernetes."""
        ...

    def async_exists(self, ensure=False) -> bool:
        """Check if this object exists in Kubernetes."""
        ...

    def create(self) -> None:
        """Create this object in Kubernetes."""
        ...

    def delete(self, propagation_policy: str | None = None) -> None:
        """Delete this object from Kubernetes."""
        ...

    def refresh(self) -> None:
        """Refresh this object from Kubernetes."""
        ...

    def async_refresh(self) -> None:
        """Refresh this object from Kubernetes."""
        ...

    def patch(self, patch, *, subresource=None, type=None) -> None:
        """Patch this object in Kubernetes."""
        ...

    def async_patch(self, patch: dict, *, subresource=None, type=None) -> None:
        """Patch this object in Kubernetes."""
        ...

    def scale(self, replicas: int | None = None) -> None:
        """Scale this object in Kubernetes."""
        ...

    def async_watch(self):
        """Watch this object in Kubernetes."""
        ...

    def watch(self):
        """Watch this object in Kubernetes."""
        ...

    def _test_conditions(
        self, conditions: list, mode: Literal["any", "all"] = "any"
    ) -> bool:
        """Test if conditions are met.

        Args:
            conditions: A list of conditions to test.
            mode: Match any condition with "any" or all conditions with "all". Defaults to "any".

        Returns:
            bool: True if any condition is met, False otherwise.
        """
        ...

    def wait(
        self,
        conditions: list[str] | str,
        mode: Literal["any", "all"] = "any",
        timeout: int | None = None,
    ):
        """Wait for conditions to be met.

        Args:
            conditions: A list of conditions to wait for.
            mode: Match any condition with "any" or all conditions with "all". Defaults to "any".
            timeout: Timeout in seconds.

        Example:
            Wait for a Pod to be ready.

            >>> from kr8s.objects import Pod
            >>> pod = Pod.get("my-pod")
            >>> pod.wait("condition=Ready")

            Wait for a Job to either succeed or fail.

            >>> from kr8s.objects import Job
            >>> job = Job.get("my-jod")
            >>> job.wait(["condition=Complete", "condition=Failed"])

            Wait for a Pod to be initialized and ready to start containers.

            >>> from kr8s.objects import Pod
            >>> pod = Pod.get("my-pod")
            >>> pod.wait(["condition=Initialized", "condition=PodReadyToStartContainers"], mode="all")

        Note:
            As of the current Kubertenetes release when this function was written (1.29) kubectl doesn't support
            multiple conditions. There is a PR to implement this but it hasn't been merged yet
            https://github.com/kubernetes/kubernetes/pull/119205.

            Given that ``for`` is a reserved word anyway we can't exactly match the kubectl API so
            we use ``condition`` in combination with a ``mode`` instead.
        """
        ...

    def annotate(self, annotations: dict | None = None, **kwargs) -> None:
        """Annotate this object in Kubernetes."""
        ...

    def label(self, labels: dict | None = None, **kwargs) -> None:
        """Add labels to this object in Kubernetes.

        Labels can be passed as a dictionary or as keyword arguments.

        Args:
            labels:
                A dictionary of labels to set.
            **kwargs:
                Labels to set.

        Example:
            >>> from kr8s.objects import Deployment
            >>> deployment = Deployment.get("my-deployment")
            >>> # Both of these are equivalent
            >>> deployment.label({"app": "my-app"})
            >>> deployment.label(app="my-app")
        """
        ...

    def keys(self) -> list:
        """Return the keys of this object."""
        ...

    def __getitem__(self, key: str) -> Any:
        """Get an item from this object."""
        ...

    def __setitem__(self, key: str, value: Any) -> None:
        """Set an item in this object."""
        ...

    def set_owner(self, owner: APIObject) -> None:
        """Set the owner reference of this object.

        See https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/

        Args:
            owner: The owner object to set a reference to.

        Example:
            >>> from kr8s.objects import Deployment, Pod
            >>> deployment = Deployment.get("my-deployment")
            >>> pod = Pod.get("my-pod")
            >>> pod.set_owner(deployment)
        """
        ...

    def async_set_owner(self, owner: APIObject) -> None:
        """Set the owner of this object."""
        ...

    def adopt(self, child: APIObject) -> None:
        """Adopt this object.

        This will set the owner reference of the child object to this object.

        See https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/

        Args:
            child: The child object to adopt.

        Example:
            >>> from kr8s.objects import Deployment, Pod
            >>> deployment = Deployment.get("my-deployment")
            >>> pod = Pod.get("my-pod")
            >>> deployment.adopt(pod)

        """
        ...

    def to_dict(self) -> dict:
        """Return a dictionary representation of this object."""
        ...

    def to_lightkube(self) -> Any:
        """Return a lightkube representation of this object."""
        ...

    def to_pykube(self, api) -> Any:
        """Return a pykube representation of this object.

        Args:
            api: A pykube API object.

        Example:
            >>> from kr8s.objects import Deployment
            >>> deployment = Deployment.get("my-deployment")
            >>> # Create a pykube API object
            >>> from pykube import HTTPClient
            >>> api = HTTPClient()
            >>> pykube_deployment = deployment.to_pykube(api)

        """
        ...

    @classmethod
    def gen(cls, *args, **kwargs): ...
    @classmethod
    def list(cls, **kwargs) -> APIObject | list[APIObject]:
        """List objects in Kubernetes.

        Args:
            **kwargs: Keyword arguments to pass to :func:`kr8s.get`.

        Returns:
            A list of objects.
        """
        ...

class Binding(APIObject):
    """A Kubernetes Binding."""

    version = "v1"
    endpoint = "bindings"
    kind = "Binding"
    plural = "bindings"
    singular = "binding"
    namespaced = True

class ComponentStatus(APIObject):
    """A Kubernetes ComponentStatus."""

    version = "v1"
    endpoint = "componentstatuses"
    kind = "ComponentStatus"
    plural = "componentstatuses"
    singular = "componentstatus"
    namespaced = False

class ConfigMap(APIObject):
    """A Kubernetes ConfigMap."""

    version = "v1"
    endpoint = "configmaps"
    kind = "ConfigMap"
    plural = "configmaps"
    singular = "configmap"
    namespaced = True

    @property
    def data(self) -> Box:
        """Data of the ConfigMap."""
        ...

    @data.setter
    def data(self, value: dict) -> None: ...

class Endpoints(APIObject):
    """A Kubernetes Endpoints."""

    version = "v1"
    endpoint = "endpoints"
    kind = "Endpoints"
    plural = "endpoints"
    singular = "endpoint"
    namespaced = True

class Event(APIObject):
    """A Kubernetes Event."""

    version = "v1"
    endpoint = "events"
    kind = "Event"
    plural = "events"
    singular = "event"
    namespaced = True

class LimitRange(APIObject):
    """A Kubernetes LimitRange."""

    version = "v1"
    endpoint = "limitranges"
    kind = "LimitRange"
    plural = "limitranges"
    singular = "limitrange"
    namespaced = True

class Namespace(APIObject):
    """A Kubernetes Namespace."""

    version = "v1"
    endpoint = "namespaces"
    kind = "Namespace"
    plural = "namespaces"
    singular = "namespace"
    namespaced = False

class Node(APIObject):
    """A Kubernetes Node."""

    version = "v1"
    endpoint = "nodes"
    kind = "Node"
    plural = "nodes"
    singular = "node"
    namespaced = False

    @property
    def unschedulable(self): ...
    def cordon(self) -> None:
        """Cordon the node.

        This will mark the node as unschedulable.
        """
        ...

    def uncordon(self) -> None:
        """Uncordon the node.

        This will mark the node as schedulable.
        """
        ...

class PersistentVolume(APIObject):
    """A Kubernetes PersistentVolume."""

    version = "v1"
    endpoint = "persistentvolumes"
    kind = "PersistentVolume"
    plural = "persistentvolumes"
    singular = "persistentvolume"
    namespaced = False

class PersistentVolumeClaim(APIObject):
    """A Kubernetes PersistentVolumeClaim."""

    version = "v1"
    endpoint = "persistentvolumeclaims"
    kind = "PersistentVolumeClaim"
    plural = "persistentvolumeclaims"
    singular = "persistentvolumeclaim"
    namespaced = True

class Pod(APIObject):
    """A Kubernetes Pod."""

    version = "v1"
    endpoint = "pods"
    kind = "Pod"
    plural = "pods"
    singular = "pod"
    namespaced = True

    def async_ready(self) -> bool:
        """Check if the pod is ready."""
        ...

    def ready(self) -> bool:
        """Check if the pod is ready."""
        ...

    def logs(
        self,
        container=None,
        pretty=None,
        previous=False,
        since_seconds=None,
        since_time=None,
        timestamps=False,
        tail_lines=None,
        limit_bytes=None,
        follow=False,
        timeout=3600,
    ) -> AsyncGenerator[str]:
        """Streams logs from a Pod.

        Args:
            container:
                The container to get logs from. Defaults to the first container in the Pod.
            pretty:
                If True, return pretty logs. Defaults to False.
            previous:
                If True, return previous terminated container logs. Defaults to False.
            since_seconds:
                If set, return logs since this many seconds ago.
            since_time:
                If set, return logs since this time.
            timestamps:
                If True, prepend each log line with a timestamp. Defaults to False.
            tail_lines:
                If set, return this many lines from the end of the logs.
            limit_bytes:
                If set, return this many bytes from the end of the logs.
            follow:
                If True, follow the logs until the timeout is reached. Defaults to False.
            timeout:
                If following timeout after this many seconds. Set to None to disable timeout.

        Returns:
            An async generator yielding log lines.


        Example:
            >>> from kr8s.objects import Pod
            >>> pod = Pod.get("my-pod")
            >>> for line in pod.logs():
            ...     print(line)

            We can also follow logs as they are generated, the generator will yield a new log line as
            it is generated by the Pod. This blocks indefinitely so we can set a timeout to break
            after some period of time, the default is ``3600`` (1hr) but can be set to ``None`` to
            disable the timeout.

            >>> from kr8s.objects import Pod
            >>> pod = Pod.get("my-pod", namespace="ns")
            >>> for line in pod.logs(follow=True, timeout=60):
            ...     # Will continue streaming logs until 60 seconds or the Pod is terminated
            ...     print(line)

        """
        ...

    def portforward(
        self,
        remote_port: int,
        local_port: int | None = None,
        address: list[str] | str = "127.0.0.1",
    ) -> SyncPortForward | AsyncPortForward:
        """Port forward a pod.

        Returns an instance of :class:`kr8s.portforward.PortForward` for this Pod.

        Example:
            This can be used as a an async context manager or with explicit start/stop methods.

            Context manager:

            >>> async with pod.portforward(8888) as port:
            ...     print(f"Forwarding to port {port}")
            ...     # Do something with port 8888


            Explict start/stop:

            >>> pf = pod.portforward(8888)
            >>> await pf.start()
            >>> print(f"Forwarding to port {pf.local_port}")
            >>> # Do something with port 8888
            >>> await pf.stop()

            Explict bind address:

            >>> async with pod.PortForward(8888, address=["127.0.0.1", "10.20.0.1"]) as port:
            ...     print(f"Forwarding to port {port}")
            ...     # Do something with port 8888 on the Pod, port will be bind to 127.0.0.1 and 10.20.0.1

        """
        ...

    def async_exec(
        self,
        command: list[str],
        *,
        container: str | None = None,
        stdin: str | BinaryIO | None = None,
        stdout: BinaryIO | None = None,
        stderr: BinaryIO | None = None,
        check: bool = True,
        capture_output: bool = True,
    ): ...
    def exec(
        self,
        command: list[str],
        *,
        container: str | None = None,
        stdin: str | BinaryIO | None = None,
        stdout: BinaryIO | None = None,
        stderr: BinaryIO | None = None,
        check: bool = True,
        capture_output: bool = True,
    ):
        """Run a command in a container and wait until it completes.

        Behaves like :func:`subprocess.run`.

        Args:
            command:
                Command to execute.
            container:
                Container to execute the command in.
            stdin:
                If set, read stdin to the container.
            stdout:
                If set, write stdout to the provided writable stream object.
            stderr:
                If set, write stderr to the provided writable stream object.
            check:
                If True, raise an exception if the command fails.
            capture_output:
                If True, store stdout and stderr from the container in an attribute.

        Returns:
            A :class:`kr8s._exec.CompletedExec` object.

        Example:
            >>> from kr8s.objects import Pod
            >>> pod = Pod.get("my-pod")
            >>> ex = await pod.exec(["ls", "-l"])
            >>> print(ex.stdout)
            >>> print(ex.stderr)
        """
        ...

    @classmethod
    def gen(
        cls,
        *,
        name=None,
        generate_name=None,
        image=None,
        namespace=None,
        annotations=None,
        command=None,
        env=None,
        resources=None,
        image_pull_policy=None,
        labels=None,
        ports=None,
        restart="Always",
    ):
        """Generate a pod definition.

        Args:
            name (str): The name of the pod.
            generate_name (str): Template for generating the name of the pod.
            namespace (str): The namespace of the pod.
            image (str): The image to use.
            annotations (dict): Annotations to add to the pod.
            command (list): Command to run in the container.
            env (dict): Environment variables to set in the container.
            resources (dict): Resources to set in the container.
            image_pull_policy (str): Image pull policy to use.
            labels (dict): Labels to add to the pod.
            ports (list|int): Ports to expose.
            restart (str): Restart policy to use.

        Returns:
            A :class:`kr8s.objects.Pod` object.

        Example:
            >>> from kr8s.objects import Pod
            >>> pod = Pod.gen(name="my-pod", image="my-image")
            >>> pod.create()

            Create an nginx Pod that exposes port 80.
            >>> from kr8s.objects import Pod
            >>> pod = Pod.gen(name="nginx", image="nginx:latest", ports=[80])
            >>> pod.create()

            Create an wordpress Pod that exposes port 80.
            >>> from kr8s.objects import Pod
            >>> pod = Pod.gen(name="wordpress", image="wordpress:latest", ports=[{"containerPort": 80}])
            >>> pod.create()

            Create a Pod that requires a GPU
            >>> from kr8s.objects import Pod
            >>> pod = Pod.gen(name="cuda-vectoradd",
            ...               image="nvidia/samples:vectoradd-cuda11.6.0-ubuntu18.04",
            ...               resources={"limits": {"nvidia.com/gpu": 1}})
        """
        ...

class PodTemplate(APIObject):
    """A Kubernetes PodTemplate."""

    version = "v1"
    endpoint = "podtemplates"
    kind = "PodTemplate"
    plural = "podtemplates"
    singular = "podtemplate"
    namespaced = True

class ReplicationController(APIObject):
    """A Kubernetes ReplicationController."""

    version = "v1"
    endpoint = "replicationcontrollers"
    kind = "ReplicationController"
    plural = "replicationcontrollers"
    singular = "replicationcontroller"
    namespaced = True
    scalable = True

    def ready(self):
        """Check if the deployment is ready."""
        ...

class ResourceQuota(APIObject):
    """A Kubernetes ResourceQuota."""

    version = "v1"
    endpoint = "resourcequotas"
    kind = "ResourceQuota"
    plural = "resourcequotas"
    singular = "resourcequota"
    namespaced = True

class Secret(APIObject):
    """A Kubernetes Secret."""

    version = "v1"
    endpoint = "secrets"
    kind = "Secret"
    plural = "secrets"
    singular = "secret"
    namespaced = True

    @property
    def data(self) -> Box:
        """Data of the Secret."""
        ...

    @data.setter
    def data(self, value: dict) -> None: ...

class Service(APIObject):
    """A Kubernetes Service."""

    version = "v1"
    endpoint = "services"
    kind = "Service"
    plural = "services"
    singular = "service"
    namespaced = True

    def proxy_http_request(
        self, method: str, path: str, port: int | None = None, **kwargs: Any
    ) -> httpx.Response:
        """Issue a HTTP request with specific HTTP method to proxy of a Service.

        Args:
            method: HTTP method to use.
            path: Path to proxy.
            port: Port to proxy to. If not specified, the first port in the
                Service's spec will be used.
            **kwargs: Additional keyword arguments to pass to the API call.
        """
        ...

    def async_proxy_http_request(
        self, method: str, path: str, port: int | None = None, **kwargs: Any
    ) -> httpx.Response: ...
    def proxy_http_get(
        self, path: str, port: int | None = None, **kwargs
    ) -> httpx.Response: ...
    def proxy_http_post(self, path: str, port: int | None = None, **kwargs) -> None:
        await self.async_proxy_http_request("POST", path, port, **kwargs)
        ...

    def proxy_http_put(
        self, path: str, port: int | None = None, **kwargs
    ) -> httpx.Response: ...
    def proxy_http_delete(
        self, path: str, port: int | None = None, **kwargs
    ) -> httpx.Response: ...
    def ready_pods(self) -> list[Pod]:
        """Return a list of ready Pods for this Service."""
        ...

    def async_ready_pods(self) -> list[Pod]:
        """Return a list of ready Pods for this Service."""
        ...

    def ready(self) -> bool:
        """Check if the service is ready."""
        ...

    def portforward(
        self,
        remote_port: int,
        local_port: int | None = None,
        address: str | list[str] = "127.0.0.1",
    ) -> SyncPortForward | AsyncPortForward:
        """Port forward a service.

        Returns an instance of :class:`kr8s.portforward.PortForward` for this Service.

        Example:
            This can be used as a an async context manager or with explicit start/stop methods.

            Context manager:

            >>> async with service.portforward(8888) as port:
            ...     print(f"Forwarding to port {port}")
            ...     # Do something with port 8888


            Explict start/stop:

            >>> pf = service.portforward(8888)
            >>> await pf.start()
            >>> print(f"Forwarding to port {pf.local_port}")
            >>> # Do something with port 8888
            >>> await pf.stop()

        """
        ...

class ServiceAccount(APIObject):
    """A Kubernetes ServiceAccount."""

    version = "v1"
    endpoint = "serviceaccounts"
    kind = "ServiceAccount"
    plural = "serviceaccounts"
    singular = "serviceaccount"
    namespaced = True

class ControllerRevision(APIObject):
    """A Kubernetes ControllerRevision."""

    version = "apps/v1"
    endpoint = "controllerrevisions"
    kind = "ControllerRevision"
    plural = "controllerrevisions"
    singular = "controllerrevision"
    namespaced = True

class DaemonSet(APIObject):
    """A Kubernetes DaemonSet."""

    version = "apps/v1"
    endpoint = "daemonsets"
    kind = "DaemonSet"
    plural = "daemonsets"
    singular = "daemonset"
    namespaced = True

class Deployment(APIObject):
    """A Kubernetes Deployment."""

    version = "apps/v1"
    endpoint = "deployments"
    kind = "Deployment"
    plural = "deployments"
    singular = "deployment"
    namespaced = True
    scalable = True

    def pods(self) -> list[Pod]:
        """Return a list of Pods for this Deployment."""
        ...

    def ready(self):
        """Check if the deployment is ready."""
        ...

class ReplicaSet(APIObject):
    """A Kubernetes ReplicaSet."""

    version = "apps/v1"
    endpoint = "replicasets"
    kind = "ReplicaSet"
    plural = "replicasets"
    singular = "replicaset"
    namespaced = True
    scalable = True

class StatefulSet(APIObject):
    """A Kubernetes StatefulSet."""

    version = "apps/v1"
    endpoint = "statefulsets"
    kind = "StatefulSet"
    plural = "statefulsets"
    singular = "statefulset"
    namespaced = True
    scalable = True

class HorizontalPodAutoscaler(APIObject):
    """A Kubernetes HorizontalPodAutoscaler."""

    version = "autoscaling/v2"
    endpoint = "horizontalpodautoscalers"
    kind = "HorizontalPodAutoscaler"
    plural = "horizontalpodautoscalers"
    singular = "horizontalpodautoscaler"
    namespaced = True

class CronJob(APIObject):
    """A Kubernetes CronJob."""

    version = "batch/v1"
    endpoint = "cronjobs"
    kind = "CronJob"
    plural = "cronjobs"
    singular = "cronjob"
    namespaced = True

class Job(APIObject):
    """A Kubernetes Job."""

    version = "batch/v1"
    endpoint = "jobs"
    kind = "Job"
    plural = "jobs"
    singular = "job"
    namespaced = True
    scalable = True
    scalable_spec = "parallelism"

class Ingress(APIObject):
    """A Kubernetes Ingress."""

    version = "networking.k8s.io/v1"
    endpoint = "ingresses"
    kind = "Ingress"
    plural = "ingresses"
    singular = "ingress"
    namespaced = True

class IngressClass(APIObject):
    """A Kubernetes IngressClass."""

    version = "networking.k8s.io/v1"
    endpoint = "ingressclasses"
    kind = "IngressClass"
    plural = "ingressclasses"
    singular = "ingressclass"
    namespaced = False

class NetworkPolicy(APIObject):
    """A Kubernetes NetworkPolicy."""

    version = "networking.k8s.io/v1"
    endpoint = "networkpolicies"
    kind = "NetworkPolicy"
    plural = "networkpolicies"
    singular = "networkpolicy"
    namespaced = True

class PodDisruptionBudget(APIObject):
    """A Kubernetes PodDisruptionBudget."""

    version = "policy/v1"
    endpoint = "poddisruptionbudgets"
    kind = "PodDisruptionBudget"
    plural = "poddisruptionbudgets"
    singular = "poddisruptionbudget"
    namespaced = True

class ClusterRoleBinding(APIObject):
    """A Kubernetes ClusterRoleBinding."""

    version = "rbac.authorization.k8s.io/v1"
    endpoint = "clusterrolebindings"
    kind = "ClusterRoleBinding"
    plural = "clusterrolebindings"
    singular = "clusterrolebinding"
    namespaced = False

class ClusterRole(APIObject):
    """A Kubernetes ClusterRole."""

    version = "rbac.authorization.k8s.io/v1"
    endpoint = "clusterroles"
    kind = "ClusterRole"
    plural = "clusterroles"
    singular = "clusterrole"
    namespaced = False

class RoleBinding(APIObject):
    """A Kubernetes RoleBinding."""

    version = "rbac.authorization.k8s.io/v1"
    endpoint = "rolebindings"
    kind = "RoleBinding"
    plural = "rolebindings"
    singular = "rolebinding"
    namespaced = True

class Role(APIObject):
    """A Kubernetes Role."""

    version = "rbac.authorization.k8s.io/v1"
    endpoint = "roles"
    kind = "Role"
    plural = "roles"
    singular = "role"
    namespaced = True

class CustomResourceDefinition(APIObject):
    """A Kubernetes CustomResourceDefinition."""

    version = "apiextensions.k8s.io/v1"
    endpoint = "customresourcedefinitions"
    kind = "CustomResourceDefinition"
    plural = "customresourcedefinitions"
    singular = "customresourcedefinition"
    namespaced = False

class Table(APIObject):
    """A Kubernetes Table."""

    version = "meta.k8s.io/v1"
    endpoint = "tables"
    kind = "Table"
    plural = "tables"
    singular = "table"
    namespaced = False

    @property
    def rows(self) -> list[dict]:
        """Table rows."""
        ...

    @property
    def column_definitions(self) -> list[dict]:
        """Table column definitions."""
        ...

def object_from_name_type(
    name: str,
    namespace: str | None = None,
    api: Api | None = None,
    _asyncio: bool = True,
) -> APIObject:
    """Create an APIObject from a Kubernetes resource name.

    Args:
        name: A Kubernetes resource name.
        namespace: The namespace of the resource.
        api: An optional API instance to use.
        _asyncio: Whether to use asyncio or not.

    Returns:
        A corresponding APIObject subclass instance.

    Raises:
        ValueError: If the resource kind or API version is not supported.
    """
    ...

def objects_from_files(
    path: str | pathlib.Path,
    api: Api | None = None,
    recursive: bool = False,
    _asyncio: bool = True,
) -> list[APIObject]:
    """Create APIObjects from Kubernetes resource files.

    Args:
        path: A path to a Kubernetes resource file or directory of resource files.
        api: An optional API instance to use.
        recursive: Whether to recursively search for resource files in subdirectories.
        _asyncio: Whether to use asyncio or not.

    Returns:
        A list of APIObject subclass instances.

    Raises:
        ValueError: If the resource kind or API version is not supported.
    """
    ...

def get_class(
    kind: str, version: str | None = None, _asyncio: bool = True
) -> type[APIObject]:
    """Get an APIObject subclass by kind and version.

    Args:
        kind: The Kubernetes resource kind.
        version: The Kubernetes API group/version.

    Returns:
        An APIObject subclass.

    Raises:
        KeyError: If no object is registered for the given kind and version.
    """
    ...

def new_class(
    kind: str,
    version: str | None = None,
    asyncio: bool = True,
    namespaced=True,
    scalable: bool | None = None,
    scalable_spec: str | None = None,
    plural: str | None = None,
) -> type[APIObject]:
    """Create a new APIObject subclass.

    Args:
        kind: The Kubernetes resource kind.
        version: The Kubernetes API version.
        asyncio: Whether to use asyncio or not.
        namespaced: Whether the resource is namespaced or not.
        scalable: Whether the resource is scalable or not.
        scalable_spec: The name of the field to use for scaling.
        plural: The plural form of the resource.

    Returns:
        A new APIObject subclass.
    """
    ...

def object_from_spec(
    spec: dict,
    api: Api | None = None,
    allow_unknown_type: bool = False,
    _asyncio: bool = True,
) -> APIObject:
    """Create an APIObject from a Kubernetes resource spec.

    Args:
        spec: A Kubernetes resource spec.
        api: An optional API instance to use.
        allow_unknown_type: Whether to allow unknown resource types.
        _asyncio: Whether to use asyncio or not.

    Returns:
        A corresponding APIObject subclass instance.

    Raises:
        ValueError: If the resource kind or API version is not supported.
    """
    ...
